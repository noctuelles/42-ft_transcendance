generator client {
    provider      = "prisma-client-js"
    binaryTargets = ["native", "debian-openssl-1.1.x"]
}

datasource db {
    provider = "postgresql"
    url      = env("DATABASE_URL")
}

// An User can have played multiple match (as the user one or user two) -> 1-n relationship.
// An User can have won multiple matches -> 1-n relationship.
// An User can have a single profile -> 1-1 relationship.
// Tables Match holds the FK-key.

model User {
    id             Int              @id @unique @default(autoincrement())
    login          String           @unique
    name           String           @unique
    profile        UserProfile      @relation(fields: [profileId], references: [id])
    profileId      Int              @unique
    status         UserStatus       @default(ONLINE)
    authIdentifier AuthIdentifier[]
    friends        User[]           @relation("UserFriends")
    friendsOf      User[]           @relation("UserFriends")
    matchAsUserOne Match[]          @relation("UserOne")
    matchAsUserTwo Match[]          @relation("UserTwo")
    matchesWon     Match[]          @relation("WinnerUser")
    matchesLost    Match[]          @relation("LooserUser")

    // Here i define an explicit many-to-many relations.
    // Three models defines this kind of relation :
    //    User and UserChannel has a many-to-many relations (an User can be in multiple channel and a Channel can have multiple User)
    //    UserOnChannel, that's the link or pivot table.
    // This pivot table defines additional fields that describes the User / UserChannel relationship,
    // such as the nickname, the status of the User on a particural Channel etc...
    // See https://www.prisma.io/docs/concepts/components/prisma-schema/relations/many-to-many-relations

    onChannels UserOnChannel[]
}

model UserOnChannel {
    user      User                @relation(fields: [userId], references: [id])
    userId    Int
    joinedAt  DateTime            @default(now())
    role      UserOnChannelRole   @default(USER)
    status    UserOnChannelStatus @default(REGULAR)
    channel   UserChannel         @relation(fields: [channelId], references: [id])
    channelId Int

    @@id([userId, channelId])
}

model UserChannel {
    id           Int                   @id @unique @default(autoincrement())
    createdAt    DateTime              @default(now())
    visibility   UserChannelVisibility @default(PUBLIC)
    password     String?
    name         String?
    participants UserOnChannel[]
}

model UserProfile {
    id            Int    @id @unique @default(autoincrement())
    playedMatches Int    @default(0)
    wonMatches    Int    @default(0)
    picture       String
    user          User?
}

model Match {
    id         Int       @id @unique @default(autoincrement())
    createdAt  DateTime  @default(now())
    finishedAt DateTime?
    bounces    Int
    userOne    User      @relation("UserOne", fields: [userOneId], references: [id])
    userTwo    User      @relation("UserTwo", fields: [userTwoId], references: [id])
    winner     User      @relation("WinnerUser", fields: [winnerId], references: [id])
    looser     User      @relation("LooserUser", fields: [looserId], references: [id])
    userOneId  Int
    userTwoId  Int
    winnerId   Int
    looserId   Int
}

model AuthIdentifier {
    identifier String @id @unique
    user       User   @relation(fields: [userId], references: [id])
    userId     Int
}

enum UserStatus {
    ONLINE
    OFFLINE
    PLAYING
}

enum UserOnChannelRole {
    OPERATOR
    ADMIN
    USER
}

enum UserOnChannelStatus {
    REGULAR
    MUTED
    BANNED
}

enum UserChannelVisibility {
    PUBLIC
    PRIVATE
    PWD_PROTECTED
}
